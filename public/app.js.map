{"version":3,"sources":["app/data/const.js","app/initialize.js","app/scenes/boot.js","app/scenes/default.js","app/scenes/menu.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArEA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArEA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjVA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlEA;AAAA","file":"public/app.js","sourcesContent":["module.exports = Object.freeze({\n  \n  colors: Object.freeze({\n    aqua: '#62f6ff',\n    black: '#000',\n    yellow: '#fed141',\n    white: '#fff'\n  }),\n  \n  fonts: Object.freeze({\n    default: 'Futura, system-ui, sans-serif'\n  }),\n  \n  hexColors: Object.freeze({\n    darkGray: 0x222222,\n    red: 0xff2200,\n    white: 0xffffff\n  })\n  \n});","window.game = new Phaser.Game({\n  // See <https://github.com/photonstorm/phaser/blob/master/src/boot/Config.js>\n  width: 800,\n  height: 600,\n  // zoom: 1,\n  // resolution: 1,\n  type: Phaser.AUTO,\n  // parent: null,\n  // canvas: null,\n  // canvasStyle: null,\n  // seed: null,\n  title: '☕️ Brunch with Phaser', // 'My Phaser 3 Game'\n  url: 'https://github.com/samme/brunch-phaser',\n  version: '0.0.1',\n  // input: {\n  //   keyboard: true,\n  //   mouse: true,\n  //   touch: true,\n  //   gamepad: false\n  // },\n  // disableContextMenu: false,\n  // banner: false\n  banner: {\n    // hidePhaser: false,\n    // text: 'white',\n    background: ['#e54661', '#ffa644', '#998a2f', '#2c594f', '#002d40']\n  },\n  // fps: {\n  //   min: 10,\n  //   target: 60\n  // },\n  // antialias: true,\n  // pixelArt: false,\n  // autoResize: false,\n  // roundPixels: false,\n  // transparent: false,\n  // clearBeforeRender: true,\n  // backgroundColor: 0x000000, // black\n  loader: {\n    // baseURL: '',\n    path: 'assets/',\n    // maxParallelDownloads: 32\n    // crossOrigin: '', // e.g., 'anonymous'\n    // timeout: 0\n  },\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: {\n        y: 300\n      }\n    }\n  },\n  // audio: {\n  //   disableWebAudio: false,\n  //   noAudio: false\n  // },\n  callbacks: {\n    postBoot: function (game) {\n      console.debug('game.config', game.config);\n    }\n  },\n  scene: [\n    require('scenes/boot'),\n    require('scenes/default'),\n    require('scenes/menu')\n  ]\n\n});\n","var CONST = require('data/const');\n\nmodule.exports = {\n\n  key: 'boot',\n\n  preload: function () {\n\t\tthis.load.image('sky', 'sky.png');\n\t\tthis.load.image('ground', 'platform.png');\n\t\tthis.load.image('star', 'star.png');\n\t\tthis.load.image('bomb', 'bomb.png');\n\t\tthis.load.spritesheet('dude', 'dude.png', { frameWidth: 32, frameHeight: 48 });\n\n    // this.load.image('sky', 'space3.png');\n    // this.load.image('logo', 'phaser3-logo.png');\n    this.load.on('progress', this.onLoadProgress, this);\n    this.load.on('complete', this.onLoadComplete, this);\n    this.createProgressBar();\n  },\n\n  create: function () {\n    // can perhaps be used as global variables to be accessed all over the application\n    this.registry.set('score', 0);\n    this.scene.start('menu');\n  },\n\n  extend: {\n\n    progressBar: null,\n\n    progressCompleteRect: null,\n\n    progressRect: null,\n\n    createProgressBar: function () {\n      var Rectangle = Phaser.Geom.Rectangle;\n      var main = Rectangle.Clone(this.cameras.main);\n\n      this.progressRect = new Rectangle(0, 0, 0.5 * main.width, 50);\n      Rectangle.CenterOn(this.progressRect, main.centerX, main.centerY);\n\n      this.progressCompleteRect = Rectangle.Clone(this.progressRect);\n\n      this.progressBar = this.add.graphics();\n    },\n\n    onLoadComplete: function (loader, totalComplete, totalFailed) {\n      console.debug('complete', totalComplete);\n      console.debug('failed', totalFailed);\n\n      this.progressBar.destroy();\n    },\n\n    onLoadProgress: function (progress) {\n      console.debug('progress', progress);\n\n      this.progressRect.width = progress * this.progressCompleteRect.width;\n      \n      this.progressBar\n        .clear()\n        .fillStyle(CONST.hexColors.darkGray)\n        .fillRectShape(this.progressCompleteRect)\n        .fillStyle(this.load.totalFailed ? CONST.hexColors.red : CONST.hexColors.white)\n        .fillRectShape(this.progressRect);\n    }\n\n  }\n\n};\n","var CONST = require('data/const');\n\n// declare variables\nvar sensorValue;\nvar pressureText;\nvar player;\nvar star;\nvar platforms;\nvar bombs;\nvar gameOver;\nvar otherPlayers;\nvar blueScoreText;\nvar redScoreText;\nvar socket;\n\n\nmodule.exports = {\n\n  key: 'default',\n\n  init: function (data) {\n    console.debug('init', this.scene.key, data, this);\n    \n    this.events.once('shutdown', this.shutdown, this);\n    \n    this.score = 0;\n  },\n\n  create: function () {\n\t\tvar self = this;\n\t\t// this.socket = io.connect(window.location.hostname, { secure: true, reconnect: true, rejectUnauthorized : false } );\n\t\tsocket = io();\n\n\t\t//listen to the “connect” message from the server. The server\n\t\t//automatically emit a “connect” message when the cleint connets.When\n\t\t//the client connects, call onsocketConnected.\n\t\tsocket.on(\"connect\", function () {\n\t\t\tconsole.log(\"client (game) connected to server\");\n\n\t\t\t// receives data from the sensor, but processed by the server. The possible values are: left, right, turn.\n\t\t\tsocket.on('sensor', function(data){\n\t\t\t\tconsole.log('data: ' + data.message);\n\t\t\t\tsensorValue = data.message;\n\t\t\t});\n\n\t\t\t// receives the raw pressure number\n\t\t\tsocket.on('pressure', function(data){\n\t\t\t\tpressureText.setText('Pressure: ' + data.pressure + 'Pa');\n\t\t\t});\n\t\t});\n\n\t\t// array that holds all the external players\n\t\totherPlayers = this.physics.add.group({\n\t\t\tbounceY: 0.2,\n\t\t\tcollideWorldBounds: true\n\t\t});\n\n\t\t/*\n\t\t* Receives an updated list of all the players connected to the game.\n\t\t* - if the socketId is the same as the current client, a new player will be create that this user will control\n\t\t* - if the socketId is not of the current socket connection, another external player will be created.\n\t\t* */\n\t\tsocket.on('currentPlayers', function (players) {\n\t\t\tObject.keys(players).forEach(function (id) {\n\t\t\t\tif (players[id].playerId === socket.id) {\n\t\t\t\t\taddPlayer(self, players[id], function(){\n\t\t\t\t\t\tinitializeColliders(self);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\taddOtherPlayers(self, players[id]);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t/*\n\t\t* New player has connected to the game, creating another player on the screen\n\t\t* */\n\t\tsocket.on('newPlayer', function (playerInfo) {\n\t\t\taddOtherPlayers(self, playerInfo);\n\t\t});\n\n\t\t/*\n\t\t* When an external player disconnects, remove it from the game.\n\t\t* */\n\t\tsocket.on('disconnect', function (playerId) {\n\t\t\totherPlayers.getChildren().forEach(function (otherPlayer) {\n\t\t\t\tif (playerId === otherPlayer.playerId) {\n\t\t\t\t\totherPlayer.destroy();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tsocket.on('gameOver', function (socketId) {\n\t\t\tvar socketPassed = socketId;\n\t\t\tself.physics.pause();\n\n\t\t\t// check if the player that lost is in the otherPlayers array\n\t\t\tif(otherPlayers){\n\t\t\t\totherPlayers.getChildren().forEach(function (otherPlayer) {\n\t\t\t\t\tif (otherPlayer.playerId == socketPassed){\n\t\t\t\t\t\totherPlayer.setTint(0x000000);\n\t\t\t\t\t}\n\t\t\t\t\t// Change with otherPlayers instance!\n\t\t\t\t\totherPlayer.anims.play('turn');\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// ...or it is the current player\n\t\t\tif(player.playerId == socketId){\n\t\t\t\tplayer.setTint(0x000000);\n\t\t\t}\n\t\t\tplayer.anims.play('turn');\n\t\t});\n\n\t\t/*\n\t\t* Information coming from the server about a player movement. Update its position.\n\t\t* */\n\t\tsocket.on('playerMoved', function (playerInfo) {\n\t\t\tconsole.log(\"playerMoved\");\n\n\t\t\totherPlayers.getChildren().forEach(function (otherPlayer) {\n\t\t\t\tif (playerInfo.playerId === otherPlayer.playerId) {\n\t\t\t\t\tconsole.log(\"Direction: \" + playerInfo.direction);\n\n\t\t\t\t\t// playing the animation for the movement communicated by the server\n\t\t\t\t\tif(playerInfo.direction === 'left'){\n\t\t\t\t\t\totherPlayer.anims.play('left', true);\n\t\t\t\t\t} else if(playerInfo.direction === 'right'){\n\t\t\t\t\t\totherPlayer.anims.play('right', true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\totherPlayer.anims.play('turn');\n\t\t\t\t\t}\n\n\t\t\t\t\totherPlayer.setPosition(playerInfo.x, playerInfo.y);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// variable that will be made true when a player is hit by a bomb\n\t\tgameOver = false;\n\n\t\t//  A simple background for the game\n\t\tthis.add.image(400, 300, 'sky');\n\n\t\t//  The platforms group contains the ground and the 2 ledges we can jump on\n\t\tplatforms = this.physics.add.staticGroup();\n\n\t\t//  Here we create the ground.\n\t\t//  Scale it to fit the width of the game (the original sprite is 400x32 in size)\n\t\tplatforms.create(400, 568, 'ground').setScale(2).refreshBody();\n\n\t\t//  Now let's create some ledges\n\t\tplatforms.create(600, 400, 'ground');\n\t\tplatforms.create(50, 250, 'ground');\n\t\tplatforms.create(750, 220, 'ground');\n\n\t\t//  Our player animations, turning, walking left and walking right.\n\t\tthis.anims.create({\n\t\t\tkey: 'left',\n\t\t\tframes: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),\n\t\t\tframeRate: 10,\n\t\t\trepeat: -1\n\t\t});\n\n\t\tthis.anims.create({\n\t\t\tkey: 'turn',\n\t\t\tframes: [ { key: 'dude', frame: 4 } ],\n\t\t\tframeRate: 20\n\t\t});\n\n\t\tthis.anims.create({\n\t\t\tkey: 'right',\n\t\t\tframes: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),\n\t\t\tframeRate: 10,\n\t\t\trepeat: -1\n\t\t});\n\n\t\t/*\n\t\t* Socket event that receives information where to spawn the next star,\n\t\t* after it has sent an event when it has been collected.\n\t\t* */\n\n\t\tsocket.on('starLocation', function (starLocation) {\n\t\t\tif (star) star.destroy();\n\t\t\tstar = self.physics.add.image(starLocation.x, starLocation.y, 'star');\n\t\t\tself.physics.add.collider(star, platforms);\n\t\t\tstar.setBounceY(Phaser.Math.FloatBetween(0.4, 0.6));\n\n\t\t\tself.physics.add.overlap(player, star, function () {\n\t\t\t\tsocket.emit('starCollected');\n\t\t\t}, null, self);\n\t\t});\n\n\t\t// Creating a group for all the bombs in the game\n\t\tbombs = this.physics.add.group();\n\n\t\t// Collisions between bombs and platforms\n\t\tthis.physics.add.collider(bombs, platforms);\n\n\t\t// Wait 3 seconds to be sure that the player is created, so the collider can be associated with it\n\t\t// setTimeout(function () {\n\t\t//   // Checking the collision between player and bombs\n\t\t//   self.physics.add.collider(player, bombs, hitBomb, null, self);\n\t\t// }, 3000);\n\n\n\t\t// Socket event that receives infor from the server on where to spawn the next bomb\n\t\tsocket.on('bombLocation', function (bombLocation) {\n\t\t\tconsole.log(\"bombLocation message received\");\n\t\t\tvar bomb = bombs.create(bombLocation.x, bombLocation.y, 'bomb');\n\t\t\tbomb.setBounce(1);\n\t\t\tbomb.setCollideWorldBounds(true);\n\t\t\tbomb.setVelocity(bombLocation.velocityX, bombLocation.velocityY);\n\t\t\tbomb.allowGravity = false;\n\t\t});\n\n\t\t// Score text\n\t\tblueScoreText = this.add.text(16, 16, '', { fontSize: '32px', fill: '#0000FF' });\n\t\tredScoreText = this.add.text(584, 16, '', { fontSize: '32px', fill: '#FF0000' });\n\n\t\t// Update event from the server with the new score\n\t\tsocket.on('scoreUpdate', function (scores) {\n\t\t\tblueScoreText.setText('Blue: ' + scores.blue);\n\t\t\tredScoreText.setText('Red: ' + scores.red);\n\t\t});\n\n\t\tthis.cursors = this.input.keyboard.createCursorKeys();\n\n    this.input.keyboard.once('keydown_Q', this.quit, this);\n    this.input.keyboard.once('keydown_R', this.restart, this);\n  },\n\n  update: function () {\n\t\tif(player){\n\t\t\tif (this.cursors.left.isDown || sensorValue == \"left\")\n\t\t\t{\n\t\t\t\tplayer.setVelocityX(-160);\n\t\t\t\tplayer.anims.play('left', true);\n\t\t\t}\n\t\t\telse if (this.cursors.right.isDown || sensorValue == \"right\")\n\t\t\t{\n\t\t\t\tplayer.setVelocityX(160);\n\t\t\t\tplayer.anims.play('right', true);\n\t\t\t}\n\t\t\telse if(sensorValue == \"turn\")\n\t\t\t{\n\t\t\t\tplayer.setVelocityX(0);\n\t\t\t\tplayer.anims.play('turn');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplayer.setVelocityX(0);\n\t\t\t\tplayer.anims.play('turn');\n\t\t\t}\n\n\t\t\tif ((this.cursors.up.isDown || sensorValue == \"up\") && player.body.touching.down)\n\t\t\t{\n\t\t\t\tplayer.setVelocityY(-330);\n\t\t\t}\n\n\t\t\t// emit player movement\n\t\t\tvar x = player.x;\n\t\t\tvar y = player.y;\n\n\t\t\tif (player.oldPosition && (x !== player.oldPosition.x || y !== player.oldPosition.y)) {\n\t\t\t\tsocket.emit('playerMovement', { x: player.x, y: player.y});\n\t\t\t}\n\n\t\t\t// save old position data\n\t\t\tplayer.oldPosition = {\n\t\t\t\tx: player.x,\n\t\t\t\ty: player.y,\n\t\t\t};\n\t\t}\n  },\n\n  extend: {\n\n    score: 0,\n\n    quit: function () {\n      this.scene.start('menu');\n    },\n\n    restart: function () {\n      this.scene.restart();\n    },\n\n    shutdown: function () {\n      this.registry.set('score', this.score);\n    },\n\n\t\taddPlayer: function(self, playerInfo, callback) {\n\t\t\tplayer = self.physics.add.sprite(playerInfo.x, playerInfo.y, 'dude');\n\t\t\tplayer.setBounce(0.2);\n\t\t\tplayer.setCollideWorldBounds(true);\n\t\t\t// self.physics.add.collider(player, platforms);\n\n\t\t\tif (playerInfo.team === 'blue') {\n\t\t\t\tplayer.setTint(0x0000ff);\n\t\t\t} else {\n\t\t\t\tplayer.setTint(0xff0000);\n\t\t\t}\n\n\t\t\tplayer.playerId = playerInfo.playerId;\n\t\t\tcallback(self);\n\t\t},\n\n\n    initializeColliders: function(self){\n      self.physics.add.collider(player, platforms);\n      self.physics.add.collider(player, bombs, hitBomb, null, self);\n    },\n\n    addOtherPlayers: function(self, playerInfo) {\n      var otherPlayer = self.add.sprite(playerInfo.x, playerInfo.y, 'dude');\n      self.physics.add.collider(otherPlayer, platforms);\n      if (playerInfo.team === 'blue') {\n        otherPlayer.setTint(0x0000ff);\n      } else {\n        otherPlayer.setTint(0xff0000);\n      }\n      otherPlayer.playerId = playerInfo.playerId;\n      otherPlayers.add(otherPlayer);\n    },\n\n    hitBomb: function(player, bomb){\n      console.log(\"Inside hitBomb\");\n\n      // send an event to server to communicate the end of current game, player has been hit\n      // self.socket.id\n      socket.emit('endGame', socket.id);\n    }\n\n  }\n\n};\n","var CONST = require('data/const');\n\nmodule.exports = {\n\n  key: 'menu',\n\n  init: function (data) {\n    console.debug('init', this.scene.key, data, this);\n  },\n\n  create: function () {\n    var self = this;\n    console.log(this);\n\n    this.add.image(400, 300, 'sky')\n      .setAlpha(0.5);\n\n    this.startText = this.add.text(400, 300, 'START', {\n      fill: 'white',\n      fontFamily: CONST.fonts.default,\n      fontSize: 48\n    })\n      .setOrigin(0.5)\n      .setShadow(0, 1, CONST.colors.aqua, 10);\n\n    this.calibrationText = this.add.text(400, 450, 'Calibration', {\n      fill: CONST.colors.aqua,\n      fontFamily: CONST.fonts.default,\n      fontSize: 30\n    })\n      .setOrigin(0.5)\n      .setShadow(0, 1, 'black', 5);\n\n    // this.input.once('pointerdown', this.start, this);\n\n    // make the two texts clickable\n\t\tthis.startText.setInteractive(new Phaser.Geom.Rectangle(0, 0, this.startText.width, this.startText.height), Phaser.Geom.Rectangle.Contains);\n\t\tthis.calibrationText.setInteractive(new Phaser.Geom.Rectangle(0, 0, this.calibrationText.width, this.calibrationText.height), Phaser.Geom.Rectangle.Contains);\n\n\t\t// highlighting selected text\n\t\tthis.input.on('pointerover', function (event, gameObjects) {\n\t\t\tgameObjects[0].setTint(0xffff00);\n\t\t});\n\n\t\tthis.input.on('pointerout', function (event, gameObjects) {\n\t\t\tgameObjects[0].clearTint();\n\t\t});\n\n\t\t// click event on start\n\t\tthis.startText.on('pointerdown', function (pointer) {\n\t\t  console.log(pointer);\n\t\t\tself.scene.start('default');\n\t\t});\n  },\n\n  extend: {\n\n    // declare other functions here\n\n    // start: function () {\n    //   this.scene.start('default');\n    // }\n\n  }\n\n};\n"]}